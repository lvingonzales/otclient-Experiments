Q1-Q4 - Fix or improve the implementation of the below methods.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Q1 - Fix or improve the implementation of the below methods

local function releaseStorage(player)
player:setStorageValue(1000, -1)
end

function onLogout(player)
if player:getStorageValue(1000) == 1 then
addEvent(releaseStorage, 1000, player)
end
return true
end

---------------------------------------------------------------------------------------------------------------------------------------------------------
ANSWER:

local storageId = 1000 -- Id constant instead of a hardcoded number, this way a different storage id can be easily checked or altered.

function onLogout(player)
    if player:getStorageValue(1000) == 1 then
        player:setStorageValue(storageId, nil) --[[ Implication is that this takes place after the player confirms they are -
                                                   logging out so I don't see the point of either a delay or a separate function
                                                   with a single line of code. Set storageValue at table position 1000 to nil 
                                                   rather than -1 for garbage collection. ]]--
    end
    return true
end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Q2 - Fix or improve the implementation of the below method

function printSmallGuildNames(memberCount)
-- this method is supposed to print names of all guilds that have less than memberCount max members
local selectGuildQuery = "SELECT name FROM guilds WHERE max_members < %d;"
local resultId = db.storeQuery(string.format(selectGuildQuery, memberCount))
local guildName = result.getString("name")
print(guildName)
end

---------------------------------------------------------------------------------------------------------------------------------------------------------
ANSWER: 

function printSmallGuildNames(memberCount)

local resultId = db.storeQuery(string.format("SELECT 'name' FROM 'guilds' WHERE 'max_members' > %d", memberCount ))
--[[ I felt there was no need to split the query into two variables and combined it into one declaration and assignment
     as was done in similar cases within the lua files of the client and server. Also the query contained various syntax errors
     such as the lack of apostrophes around the table and column names and the semi-colon at the end. ]]--

    if resultId then 
        repeat
            local guildName = result.getString(resultId, "name")
            print(guildName)
        until not result.next(resultId)
        result.free (resultId)
    end
    --[[ the way it was done before would only print a single name if it even got this far due to the syntax error in selectGuildQuery,
         using an if statement ensures code isn't run unnecessarily in case there are no matching entries according to the query, and a
         repeat until will iterate through each matching entry, fetching the name and printing it without duplicates thanks to "result.next (resultId)",
         then in order to prevent any problems at the next query, the values in resultId are freed. ]]--
end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Q3 - Fix or improve the name and the implementation of the below method

function do_sth_with_PlayerParty(playerId, membername)
player = Player(playerId)
local party = player:getParty()

for k,v in pairs(party:getMembers()) do
if v == Player(membername) then
party:removeMember(Player(membername))
end
end
end

---------------------------------------------------------------------------------------------------------------------------------------------------------
ANSWER:

function kickPartyMember (playerid, membername)     --[[ Judging from the above code, I believe it is trying to kick a specified player from a party, 
                                                         thus I have named the function kikPartyMember(), the arguments are the same]]-- 

    local member = Player(membername)               -- member is assigned to a player object based on the member name argument
    local party = player:getParty()                 --[[ To a local function party I assigned the return value of the class function getParty(), 
                                                         which the above code implies to bethe parties id. ]]--
    if party then 

        for k,v in pairs(party:getMembers()) do 
            if v:getId() == member:getId() then     -- Checks the Ids of the players in the table and the member to be kicked instead of creating a new 
                party:removeMember(member)          -- player object every iteration, return true if player was removed from the party successfully
                return true
            end

        end

    end
    return false -- Returns false if the player specified players aren't in a party
end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Q4 - Assume all method calls work fine. Fix the memory leak issue in below method

void Game::addItemToPlayer(const std::string& recipient, uint16_t itemId)
{
Player* player = g_game.getPlayerByName(recipient);
if (!player) {
player = new Player(nullptr);
if (!IOLoginData::loadPlayerByName(player, recipient)) {
return;
}
}

Item* item = Item::CreateItem(itemId);
if (!item) {
return;
}

g_game.internalAddItem(player->getInbox(), item, INDEX_WHEREEVER, FLAG_NOLIMIT);

if (player->isOffline()) {
IOLoginData::savePlayer(player);
}
}

---------------------------------------------------------------------------------------------------------------------------------------------------------
ANSWER:

--[[ Fixing the memory leak in this code can be achieved using smart pointers or the delete() function if raw pointers are preferred, OTClient coding style dictates that 'delete'
     must never be used, so I will use smart pointers instead. ]]--

#include <memory> -- The memory header is included so that I can use std::unique_ptr.

void Game::addItemToPlayer(const std::string& recipient, uint16_t itemId)
{
    std::unique_ptr<Player> player = g_game.getPlayerByName(recipient); -- The Player* raw pointer is replaced with a smart pointer so that memory is managed if player is not found.
    if (!player) {
        player = new Player(nullptr);
        if (!IOLoginData::loadPlayerByName(player, recipient)) {
            return;
        }
    }

    std::unique_ptr<Item> item = Item::CreateItem(itemId);              **-- Similar to above, a smart Pointer is used to manage memory should item be empty.
    if (!item) {
        return;
    }

    g_game.internalAddItem(player->getInbox(), item, INDEX_WHEREEVER, FLAG_NOLIMIT);

    if (player->isOffline()) {
        IOLoginData::savePlayer(player);
    }
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
